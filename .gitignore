

module traffic_controller( clear,s1,s2,s3, clock, count,load, value, timeup,L1,L2,L3); 

// I/O ports
output  reg [1:0] L1,L2,L3;
output reg timeup;
input  [7:0] value;
input clear, s1,s2,s3;   
input clock, load,count;  
parameter flash =2'b00, green = 2'b01, yellow = 2'b10, red = 2'b11;  
parameter true = 1'b1;
parameter false = 1'b0;

// State definition        south_to_north    west_to_east
parameter st0 = 7'b0000001,     //f             f 
          st1 = 7'b0000010,     //r             r
          st2 = 7'b0000100,     //g             r
          st3 = 7'b0001000,     //y             r
          st4 = 7'b0010000,     //r             r
          st5 = 7'b0100000,     //r             g         
          st6 = 7'b1000000;      //r             y       
       
reg [5:0] state, next_state;
counter c1(clock, load, value, count, timeup); 
// State changes only at positive edge of clock 
        always@(posedge clock) 
        begin 
        if (clear)
        state <= st0;         
        else  
        state <= next_state;   //State change
        end
 
      always@(state)
      begin 
      
      case (state)

    // st0:     begin 
        //      L1=flash;
        //      L2=flash;
         //     L3 =flash;            
         //     end 
      
     st0:     begin
              L1=red;
              L2=red;
              L3=red;     
              end

     st1:     begin
              L1=red;
              L2=green;
              L3=green; 
              end

     st2:     begin  
              L1=red;
	      L2=yellow;
              L3=yellow;
              end

     st3:     begin  
              L1=red;
	      L2=red;
	      L3=red;
              end

     st4:      begin  
               L1=green;
               L2=red;
               L3=red;
               end

     st5:     begin 
              L1=yellow;
              L2=red;
	      L3=red; 
              end
     endcase 
  end 

// State machine using case statements 
  always@(state or s1,s2,s3)
  begin 
       case (state)

                 //  st0:		begin 
                   	//	if (s1==false && (s2==false && s3==false)) 
                   	//	next_state = st0;
                   	//	else
                   	//	next_state = st1;
                   	//	end
   
                   st0: 	begin  
				value<=8'b00000001;      //value of one is passed for the counter
				//load<=true; 
             			//count<=true; 
                  		if(s1 == false  && (s2==false && s3==false))     
                  		next_state = st0;
                                else if(s1==false ||((s2== false || s3==true)|| (s2== true || s3==false)))
                                next_state = st1;
                  		else if(s1==true &&(s2== false || s3==false))  //check if condition                 
                  		next_state = st4;
                   		end 

                   st1:		begin  
             			value<=8'b00101101;   //value of 45 is passed for delay
              			//load=true; 
              			//count=true;    
                   		//if(s1==false &&((s2==true || s3 == true)||(s2== true || s3==false)|| (s2==false || s3==true)))                
                  		next_state = st2; 
                  		//else if (s1==true &&(s2==false && s3==false))
                   		//next_state = st2;    
                  		end

                   st2:		begin
               			value =8'b00000101;   //value of 5 is passed for delay
              			//load=true; 
              			//count=true; 
                   		next_state = st3;
                   		end 
  
                   st3: 	begin   
              			value=8'b00000001;      //value of one is passed for delay
              			//load=true; 
              			//count=true;
                   		next_state = st4; 
                   		end 

                   st4:		begin 
                		value=8'b00001111;   //value of 15 is passed for delay
                                if(s1==true &&(s2==false || s3 == false))   
              			//load=true; 
              			//count=true;     
                   		next_state = st4; 
                                else 
                                next_state = st5; 
                  		end

                   st5:		begin  
             			value=8'b00000101;    //value of 5 is passed for delay
              			//load=true; 
              			//count=true;    
                   		next_state = st0; 
                   		end

                  		default next_state = st0;
     endcase 
 end
 
endmodule

module counter(clk, load, value, count, timeup);
input clk, load, count;
input [7:0] value;
output reg timeup;
reg [7:0] c;
always @(c)
begin
if (c == 0)
timeup <= 1;   //DOUBT
else
timeup <= 0;  //DOUBT       
end
always @(posedge clk)
begin
if (load)
c <= value;
else if (count && (c != 0))
c <= c - 8'b1;
else
c <= c;
end
endmodule 
